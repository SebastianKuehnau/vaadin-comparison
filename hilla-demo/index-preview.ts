/*
 * This file is generated by the Vaadin Studio extension for VS Code.
 * We hope to avoid pollluting the application directory in the future, but we're not there yet.
 */

const addCssBlock = (block: string) => {
  const tpl = document.createElement('template');
  tpl.innerHTML = block;
  document.head['insertBefore'](tpl.content, document.head.firstChild);
};

addCssBlock('<custom-style><style include="lumo-color lumo-typography"></style></custom-style>');

import { LitElement } from 'lit-element';
import { render, PropertyCommitter } from 'lit-html';
import { applyPolyfill } from 'custom-elements-hmr-polyfill';

import { init } from 'snabbdom/build/package/init';
import { vnode } from 'snabbdom/build/package/vnode';
import { h } from 'snabbdom/build/package/h';
import { attributesModule } from 'snabbdom/build/package/modules/attributes';

import { applyTheme } from './frontend/generated/theme';

import { htmlDomApi, DOMAPI } from 'snabbdom/build/package/htmldomapi';

import { ConnectClient } from '@vaadin/flow-frontend/Connect';

ConnectClient.prototype.call = async () => {
  window.parent.postMessage({ command: 'showServerCallWarning' }, '*');
};

applyTheme(document);

// Add template element support to the DOM API used by Snabbdom
const patchedHtmlDomApi = Object.assign(htmlDomApi, {
  appendChild: (node: Node, child: Node): void => {
    if (node instanceof HTMLTemplateElement) {
      node.content.appendChild(child);
    } else {
      node.appendChild(child);
    }
  },
  removeChild: (node: Node, child: Node): void => {
    if (node instanceof HTMLTemplateElement) {
      node.content.removeChild(child);
    } else {
      node.removeChild(child);
    }
  },
  insertBefore: (parentNode: Node, newNode: Node, referenceNode: Node | null): void => {
    if (parentNode instanceof HTMLTemplateElement) {
      parentNode.content.insertBefore(newNode, referenceNode);
    } else {
      parentNode.insertBefore(newNode, referenceNode);
    }
  },
});

// ImportStatement insertion example: "import {showNotification as showNotification_VAADIN_STUDIO_IMPORT_SUFFIX} from '@vaadin/flow-frontend/a-notification'"
/*ImportStatements*/

var imports: string[] = [
  // Import insertion example: "'{showNotification} from @vaadin/flow-frontend/a-notification'"
  /*Imports*/
];
import { VNode, VNodeData } from 'snabbdom/build/package/vnode';
import { Module } from 'snabbdom/build/package/modules/module';

const populateProps = (vnode: VNode, partProperties: Map<Element, Set<string>>): void => {
  if (vnode.elm?.nodeType == Node.ELEMENT_NODE) {
    vnode.data = vnode.data || {};

    // Remove incomplete .something attributes that would otherwise cause explosions while typing
    Object.keys(vnode.data.attrs || {})
      .filter((key) => key.startsWith('.'))
      .forEach((key) => delete vnode.data!.attrs![key]);

    const props: Record<string, any> = (vnode.data.props = {});

    Object.keys(vnode.elm).forEach((key) => (props[key] = (vnode.elm as any)[key]));

    // TODO maybe extract inherited properties in some sensible way, but only if the value has been changed compared to the default
    // There are plenty of generic properties such as .children or .setAttribute that should be completely ignored

    partProperties.get(vnode.elm as Element)?.forEach((key) => (props[key] = (vnode.elm as any)[key]));
  }

  if (!vnode.children) {
    return;
  }

  for (let i = 0; i < vnode.children.length; i++) {
    let child = vnode.children[i];
    if (typeof child !== 'string') {
      populateProps(child, partProperties);
    }
  }
};

function toVNode(node: Node, domApi?: DOMAPI): VNode {
  const api: DOMAPI = domApi !== undefined ? domApi : patchedHtmlDomApi;
  let text: string;
  if (api.isElement(node)) {
    const id = (node as HTMLElement).id ? '#' + (node as HTMLElement).id : '';
    const cn = (node as HTMLElement).getAttribute('class');
    const c = cn ? '.' + cn.split(' ').join('.') : '';
    const sel = api.tagName(node).toLowerCase() + id + c;
    const attrs: any = {};
    const children: VNode[] = [];
    let name: string;
    let i: number, n: number;
    const elmAttrs = (node as HTMLElement).attributes;
    const elmChildren = node instanceof HTMLTemplateElement ? node.content.childNodes : node.childNodes;
    for (i = 0, n = elmAttrs.length; i < n; i++) {
      name = elmAttrs[i].nodeName;
      if (name !== 'id' && name !== 'class') {
        attrs[name] = elmAttrs[i].nodeValue;
      }
    }
    for (i = 0, n = elmChildren.length; i < n; i++) {
      children.push(toVNode(elmChildren[i], domApi));
    }
    return vnode(sel, { attrs }, children, undefined, node);
  } else if (api.isText(node)) {
    text = api.getTextContent(node) as string;
    return vnode(undefined, undefined, undefined, text, node);
  } else if (api.isComment(node)) {
    text = api.getTextContent(node) as string;
    return vnode('!', {}, [], text, node as any);
  } else {
    return vnode('', {}, [], undefined, node as any);
  }
}

const updateProps = (oldVnode: VNode, vnode: VNode): void => {
  let key: string;
  let cur: any;
  let old: any;
  let elm = vnode.elm;
  let oldProps = (oldVnode.data as VNodeData).props;
  let props = (vnode.data as VNodeData).props;

  if (!oldProps && !props) {
    return;
  }
  if (oldProps === props) {
    return;
  }
  oldProps = oldProps || {};
  props = props || {};

  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || (elm as any)[key] !== cur)) {
      (elm as any)[key] = cur;
    }
  }

  // Addition compared to original implementation: also (try to) remove removed props
  const anyElm = elm as any;
  for (key in oldProps) {
    if (!(key in props)) {
      if (key in elm!.constructor.prototype) {
        // This is an inherited property - we cannot just delete it but must instead restore the default value

        const defaultValue = (document.createElement((elm as Element).tagName) as any)[key];
        anyElm[key] = defaultValue;
      } else {
        delete anyElm[key];
      }
    }
  }
};

const propsModule: Module = { create: updateProps, update: updateProps };

// Use custom elements polyfill to speed up things
// Might also help avoid leaking memory since old classes can maybe be reclaimed
(window as any).HMR_SKIP_DEEP_PATCH = true;
applyPolyfill();

// Previously rendered snabbdom tree, used for diffing
let oldTree: any;

let model: Model;

const patch = init([attributesModule, propsModule], patchedHtmlDomApi);

// Empty shell that will host the preview DOM
class ShellElement extends LitElement {}

let shellElement: ShellElement | null = null;
let renderTarget: ShellElement | ShadowRoot | null;

interface Id {
  treeId: number;
  nodeId: number;
}

let currentlySelectedElementId: Id | null;

// This section should be in a separate module that is updated with HMR when imports are updated
(window as any).importScope = {
  // ImportScope insertion example: "showNotification : showNotification_VAADIN_STUDIO_IMPORT_SUFFIX"
  /*ImportScopes*/
};
const importHeader = `
  // ImportHeader insertion example: "const showNotification = window.importScope.showNotification"
  /*ImportHeaders*/
`;

const update = async (code: string) => {
  console.debug('Start update');
  const fullCode = importHeader + code;

  const url = URL.createObjectURL(new Blob([fullCode], { type: 'application/javascript' }));

  let c: CustomElementConstructor[] = [];
  const hmrPolyfillDefineFn = CustomElementRegistry.prototype.define;
  CustomElementRegistry.prototype.define = function (
    name: string,
    constructor: CustomElementConstructor,
    options?: ElementDefinitionOptions
  ) {
    if (shellElement === null) {
      // Register and instantiate the shell element when we know the name to use
      hmrPolyfillDefineFn.apply(this, [name, ShellElement]);
      shellElement = document.createElement(name) as ShellElement;
      document.getElementById('outlet')?.appendChild(shellElement);
    }
    hmrPolyfillDefineFn.apply(this, ['my-element', constructor, options]);
    c.push(constructor);
  };
  await eval('import(url)');
  CustomElementRegistry.prototype.define = hmrPolyfillDefineFn;

  URL.revokeObjectURL(url);

  if (c.length === 0) {
    document.getElementById('outlet')!.innerText = 'The file must define a custom element.';
    return;
  } else if (c.length > 1) {
    document.getElementById(
      'outlet'
    )!.innerText = `The file defines ${c.length} custom elements. Do not know which one to preview. Please define only one custom element in the file.`;
    return;
  }

  // Override static LitElement helper that delegates to lit-html render
  (c[0] as any).render = (result: unknown, container: Element | DocumentFragment, options: any) => {
    let tempContainer = document.createDocumentFragment();
    let partProperties: Map<Element, Set<string>> = new Map();
    let originalImport = document.importNode;
    let originalCommit = PropertyCommitter.prototype.commit;

    try {
      // Prevent custom elements from upgrading when lit-html tries to be friendly
      document.importNode = (node, deep) => node.cloneNode(deep) as any;

      // Record which properties are set directly by lit-html
      PropertyCommitter.prototype.commit = function () {
        originalCommit.apply(this, arguments as any);
        let props = partProperties.get(this.element);
        if (!props) {
          props = new Set();
          partProperties.set(this.element, props);
        }
        props.add(this.name);
      };

      render(result, tempContainer, options);
    } finally {
      document.importNode = originalImport;
      PropertyCommitter.prototype.commit = originalCommit;
    }

    try {
      document.importNode = (node, deep) => node.cloneNode(deep) as any;

      render(result, tempContainer, options);
    } finally {
      document.importNode = originalImport;
    }

    let newTree = h(
      '#fragment',
      {},
      Array.from(tempContainer.childNodes).map((child) => toVNode(child))
    );

    populateProps(newTree, partProperties);

    let oldRenderTarget = renderTarget;
    if (container === options.eventContext) {
      renderTarget = shellElement;
      // Reset for rendering to the light DOM
      shellElement!.shadowRoot!.innerHTML = '<slot></slot>';
    } else if (container === options.eventContext.shadowRoot) {
      renderTarget = shellElement!.shadowRoot;
      // Reset for rendering to the shadow DOM
      shellElement!.textContent = '';
    } else {
      throw Error('Element must use itself or its shadow root as the render root');
    }

    if (!oldTree || renderTarget !== oldRenderTarget) {
      oldTree = vnode('#fragment', { attrs: {} }, undefined, undefined, renderTarget as any);
    }

    oldTree = patch(oldTree, newTree);

    //@ts-ignore
    if (container.adoptedStyleSheets) {
      //@ts-ignore
      shellElement.shadowRoot!.adoptedStyleSheets = container.adoptedStyleSheets;
    } else {
      //@ts-ignore
      shellElement.shadowRoot!.adoptedStyleSheets = [];
    }

    refreshSelection();

    console.debug('Complete update');
    window.parent.postMessage({ command: 'updateFinished' }, '*');
  };

  // Emulate attaching so that it will render itself
  const customElementInstance = document.createElement('my-element') as any;
  customElementInstance.connectedCallback();
};

const refresh = (code: string) => {
  const postTranspile = new XMLHttpRequest();
  postTranspile.open('POST', '/VAADIN/transpile');
  postTranspile.setRequestHeader('Content-Type', 'text/plain');
  postTranspile.onreadystatechange = () => {
    if (postTranspile.readyState === 4 && postTranspile.status === 200) {
      const response = JSON.parse(postTranspile.responseText);
      const templateImports = response.templateImports;
      if (shouldUpdateImports(templateImports)) {
        updateImports(templateImports);
        window.parent.postMessage({ command: 'templateImports', templateImports: templateImports }, '*');
      } else {
        update(response.transpiledCode);
      }
    }
  };
  postTranspile.send(code);
};

window.addEventListener(
  'message',
  (event) => {
    const message = event.data;
    console.debug('App frame received: ' + JSON.stringify(message));
    switch (message.command) {
      case 'transpile': {
        const updateData = getPreviewUpdateData(message.code, message.indexes);
        model = updateData.model;
        refresh(updateData.code);
        break;
      }
      case 'selectFromEditor': {
        const id = getIdForOffset(message.offset);
        if (id) {
          showSelectIndicatorOn(id);
        }
        return;
      }
    }
  },
  false
);

window.parent.postMessage({ command: 'previewReady' }, '*');

let indicatorAnimation: Animation | undefined;
const indicator = document.createElement('div');
{
  indicator.style.position = 'absolute';
  indicator.style.backgroundColor = 'rgb(255, 203, 106)';
  indicator.style.opacity = '0';
  indicator.style.zIndex = '10000';
  indicator.style.pointerEvents = 'none';
  const inner = document.createElement('div');
  inner.style.height = '100%';
  inner.style.backgroundColor = 'rgb(138, 255, 173)';
  inner.style.boxSizing = 'border-box';
  inner.style.border = '0px solid yellow';
  indicator.appendChild(inner);
  const innermost = document.createElement('div');
  innermost.style.height = '100%';
  innermost.style.backgroundColor = 'rgb(149, 195, 255)';
  inner.appendChild(innermost);
}
document.body.appendChild(indicator);

document.body.onmousedown = (event) => {
  const owner = renderTarget instanceof ShadowRoot ? renderTarget : renderTarget!.ownerDocument;
  const el = owner!.elementFromPoint(event.clientX, event.clientY);
  const id = {
    nodeId: Number(el!.getAttribute('data-node-id')!),
    treeId: Number(el!.getAttribute('data-tree-id')!),
  };
  console.debug(` Element found: ${el!.outerHTML} id found: ${JSON.stringify(id)}`);

  window.parent.postMessage({ command: 'selectFromPreview', ...getRangeForId(id) }, '*');
  showSelectIndicatorOn(id, Number.MAX_VALUE);
  event.preventDefault();
  event.stopPropagation();
};

const refreshSelection = () => {
  if (currentlySelectedElementId) {
    showSelectIndicatorOn(currentlySelectedElementId);
  }
};
const showSelectIndicatorOn = (id: Id, delay?: number) => {
  console.debug('recieved id: ' + JSON.stringify(id));
  if (renderTarget === null) {
    return;
  }

  delay = delay ?? 800;
  const el = renderTarget?.querySelector(`[data-tree-id="${id.treeId}"][data-node-id="${id.nodeId}"]`);
  if (el) {
    currentlySelectedElementId = id;
    // POSITION
    const rect = el.getBoundingClientRect();
    indicator.style.top = rect.top + window.scrollY + 'px';
    indicator.style.left = rect.left + window.scrollX + 'px';
    indicator.style.width = rect.width + 'px';
    indicator.style.height = rect.height + 'px';
    // MARGIN
    const cs = window.getComputedStyle(el);
    indicator.style.padding = cs.margin;
    indicator.style.marginTop = '-' + cs.marginTop;
    indicator.style.marginRight = '-' + cs.marginRight;
    indicator.style.marginBottom = '-' + cs.marginBottom;
    indicator.style.marginLeft = '-' + cs.marginLeft;
    // PADDING
    const padding = indicator.firstElementChild as HTMLElement;
    padding.style.padding = cs.padding;
    // BORDER
    padding.style.borderWidth = cs.borderWidth;
    // ANIMATE
    indicatorAnimation?.cancel();
    indicatorAnimation = indicator.animate([{ opacity: 0.5 }, { opacity: 0.5 }, { opacity: 0.0 }], {
      duration: delay,
      iterations: 1,
    });

    currentlySelectedElementId = null;
  } else {
    console.debug('Did not find element with id ' + id);
    indicatorAnimation?.cancel();
    indicator.style.opacity = '0';
  }
};

const log = (msg: string) => {
  if (msg) {
    window.parent.postMessage({ logMessage: msg, command: 'output' }, '*');
  }
};

const _log = console.log;
console.log = function (message?: any, ...optionalParams: any[]) {
  _log(message, ...optionalParams);
  log(message);
};

window.onerror = function (event: Event | string): any {
  log(event.toString());
};

window.onunhandledrejection = function (event: PromiseRejectionEvent) {
  log(event.reason.toString());
};

function shouldUpdateImports(templateImports: any[]) {
  if (imports.length != templateImports.length) {
    return true;
  }

  const currentImports = new Set(imports);
  for (var templateImport of templateImports) {
    if (!currentImports.has(templateImport.importExpression)) {
      return true;
    }
  }
  return false;
}

function updateImports(templateImports: any[]) {
  imports = templateImports.map((templateImport) => templateImport.importExpression);
}
const getIdForOffset = (offset: number) => {
  let smallestRange = Number.MAX_SAFE_INTEGER;
  let id: Id | undefined;

  model.forEach((tree, treeIndex) => {
    tree.indexes.forEach((value, index) => {
      if (value.start <= offset && offset <= value.end && value.end - value.start < smallestRange) {
        id = { treeId: treeIndex, nodeId: tree.ids[index] };
        smallestRange = value.end - value.start;
      }
    });
  });
  return id;
};

const getRangeForId = (id: Id) => {
  const tree = model[id.treeId];
  const index = tree.indexes[tree.ids.indexOf(id.nodeId)];
  if (index) {
    return { start: index.start, end: index.end };
  }
  return null;
};

interface Index {
  start: number;
  end: number;
}

interface ParsedTemplate {
  originalTemplateString: string;
  atir: string[];
  ids: number[];
  indexes: Index[];
}

interface Id {
  treeId: number;
  nodeId: number;
}

interface Model extends Array<ParsedTemplate> {}

// Returns the index of a substring in a string while ignoring
// white space. -1 if no match is found.
const indexOfIgnoreWhitespace = (startIndex: number, substr: string, str: string) => {
  let noWhitespace = substr.replace(/\s/g, '');
  // +1 to avoid recognizing the same element repeated
  let i: number = startIndex + 1;
  do {
    if (!/\s/.test(str[i])) {
      let j = i;
      let matchedLenght = 0;
      let match = '';
      do {
        if (/\s/.test(str[j])) {
          j++;
        } else {
          if (str[j].toUpperCase() === noWhitespace[matchedLenght].toUpperCase()) {
            // match, continue to next character
            match = match + str[j];
            j++;
            matchedLenght++;
          } else {
            // no match
            break;
          }
        }
      } while (matchedLenght < noWhitespace.length && j < str.length);
      if (matchedLenght === noWhitespace.length) {
        return i;
      }
    }
    i++;
  } while (i < str.length);
  return -1;
};

enum Instruction {
  OpenNode = '__(__',
  CloseNode = '__)__',
  SetProperty = '__=__',
}

const ATIRToHTML = (atir: string[], modelId = -1) => {
  let stack: string[] = [];
  let tagTree: string[] = [];
  let currentTag = '';
  let result = '';
  let currentClosed = true;

  atir.forEach((str, index) => {
    let trimmed = str.trim();
    switch (trimmed) {
      case Instruction.OpenNode: {
        if (!currentClosed) {
          result = result + '>';
          currentClosed = true;
        }
        tagTree.push(currentTag);
        currentTag = stack.pop() || '';
        if (currentTag !== 'TEXT') {
          result = result.concat('<' + currentTag + ' data-node-id="' + index + '"');

          if (modelId >= 0) {
            result = result.concat(' data-tree-id="' + modelId + '"');
          }
          currentClosed = false;
        }
        break;
      }
      case Instruction.CloseNode: {
        if (currentTag !== 'TEXT') {
          if (!currentClosed) {
            result = result + '>';
            currentClosed = true;
          }
          result = result.concat(`</${currentTag}>`);
        }
        currentTag = tagTree.pop() || '';
        break;
      }
      case Instruction.SetProperty: {
        let tos = stack.pop();
        let nos = stack.pop();
        if (!nos || !tos) {
          return;
        }
        if (nos === 'content' && currentTag == 'TEXT') {
          result = result.concat(tos);
        } else {
          const quoteChar = tos.includes('"') ? "'" : '"';

          result = result.concat(` ${nos}=${quoteChar}${tos}${quoteChar}`);
        }
        break;
      }
      default:
        stack.push(str);
    }
  });

  return result;
};

const HTMLToATIR = (fullString: string, htmlSubString: string) => {
  const indexes: Index[] = [];
  const ids: number[] = [];
  const atir: string[] = [];

  const parseAttributes = (htmlEl: HTMLElement, html: string) => {
    const htmlLowercase = html.toLowerCase();
    const attributes = htmlEl.attributes;
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes.item(i);
      const attributeName = attribute!.name;
      let actualAttrName = attributeName;

      // check if it is actually a property
      if (['.', '?', '@'].includes(attributeName[0])) {
        let lastIndex = 0;
        // find the original name of the property if it has different formatting
        // example: textcontent vs. textContent
        while (htmlLowercase.indexOf(attributeName, lastIndex) > 0) {
          const newIndex = htmlLowercase.indexOf(attributeName, lastIndex);
          const originalName = html.slice(newIndex, newIndex + attributeName.length);
          // Check if the original name was different from the serialized one. Also
          // check if the original had whitespace before it, to avoid collisions with
          // object access, for example someObject.Foo and .foo=${..}
          if (originalName !== attributeName && /\s/.test(html[newIndex - 1])) {
            actualAttrName = originalName;
            break;
          }
          lastIndex = newIndex + attributeName.length;
        }
      }

      atir.push(actualAttrName);
      atir.push(attribute!.value);
      atir.push(Instruction.SetProperty);
    }
  };

  const getChildren = (node: HTMLElement) => {
    if (node.childNodes && node.childNodes.length > 0) {
      return node.childNodes;
    }
    if (node instanceof HTMLTemplateElement) {
      return node.content.childNodes;
    }
    return [];
  };

  const parseTree = (parent: HTMLElement) => {
    for (let el of Array.from(getChildren(parent))) {
      if (el.nodeType === Node.TEXT_NODE) {
        atir.push('TEXT');
        atir.push(Instruction.OpenNode);
        atir.push('content');
        atir.push((el as any).textContent || '');
        atir.push(Instruction.SetProperty);
        atir.push(Instruction.CloseNode);
      } else {
        const htmlEl = el as HTMLElement;
        const sourceText = htmlEl.outerHTML;

        // determine the position of this piece of HTML in the text
        const startIndex = indexOfIgnoreWhitespace(
          indexes.length > 0 ? indexes[indexes.length - 1].start : 0,
          // normalize boolean attributes 'key=""' to just 'key'
          sourceText.replace(/=""/g, ''),
          fullString
        );
        const endIndex = startIndex + sourceText.length;

        indexes.push({
          start: startIndex,
          end: endIndex,
        });

        ids.push(atir.length + 1);
        atir.push(htmlEl.tagName.toLowerCase());
        atir.push(Instruction.OpenNode);

        parseAttributes(htmlEl, fullString.slice(startIndex, endIndex));

        let children = getChildren(el as HTMLElement);
        if (children.length > 0) {
          parseTree(el as HTMLElement);
        }
        atir.push(Instruction.CloseNode);
      }
    }
  };

  const parser = new DOMParser();
  const domTree = parser.parseFromString(htmlSubString.trim(), 'text/html');
  parseTree(domTree.body);

  return { atir: atir, indexes: indexes, ids: ids };
};

export const getPreviewUpdateData = (code: string, indexes: Index[]): { code: string; model: Model } => {
  let model: Model = [];

  for (const index of indexes) {
    const original = code
      .substring(index.start, index.end)
      .trim()
      .replace(/^html(\s)*`/, '')
      .replace(/`$/, '');
    model.push({ originalTemplateString: original, ...HTMLToATIR(code, original) });
  }

  let codeWithData = code;
  model.forEach((model, index) => {
    const newHTML = ATIRToHTML(model.atir, index);
    codeWithData = codeWithData.replace(model.originalTemplateString, newHTML);
  });

  return { code: codeWithData, model: model };
};
